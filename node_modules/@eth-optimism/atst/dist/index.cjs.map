{"version":3,"sources":["../src/index.ts","../src/constants/attestationStationAddress.ts","../src/lib/createKey.ts","../src/lib/createValue.ts","../src/lib/readAttestations.ts","../src/types/DataTypeOption.ts","../src/lib/abi.ts","../src/lib/parseAttestationBytes.ts","../src/lib/readAttestation.ts","../src/lib/getEvents.ts","../src/lib/prepareWriteAttestation.ts","../src/lib/prepareWriteAttestations.ts","../src/lib/writeAttestation.ts"],"sourcesContent":["// constants\nexport { ATTESTATION_STATION_ADDRESS } from './constants/attestationStationAddress'\n// lib\nexport { encodeRawKey, createKey } from './lib/createKey'\nexport { createValue, stringifyAttestationBytes } from './lib/createValue'\nexport {\n  readAttestation,\n  readAttestationAddress,\n  readAttestationBool,\n  readAttestationNumber,\n  readAttestationString,\n} from './lib/readAttestation'\nexport { readAttestations } from './lib/readAttestations'\nexport { getEvents } from './lib/getEvents'\nexport { prepareWriteAttestation } from './lib/prepareWriteAttestation'\nexport { prepareWriteAttestations } from './lib/prepareWriteAttestations'\nexport { writeAttestation } from './lib/writeAttestation'\nexport { abi } from './lib/abi'\nexport {\n  parseAttestationBytes,\n  parseAddress,\n  parseNumber,\n  parseBool,\n  parseString,\n} from './lib/parseAttestationBytes'\n// types\nexport type { AttestationCreatedEvent } from './types/AttestationCreatedEvent'\nexport type { AttestationReadParams } from './types/AttestationReadParams'\nexport type { DataTypeOption } from './types/DataTypeOption'\nexport type { WagmiBytes } from './types/WagmiBytes'\n","/**\n * The attestation station contract address\n * The attestation station contract is deterministically deployed\n * to 0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77\n */\nexport const ATTESTATION_STATION_ADDRESS =\n  '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n","import { ethers } from 'ethers'\n\nimport { WagmiBytes } from '../types/WagmiBytes'\n\n/**\n * Creates an attesation key from a raw string\n * Converts to bytes32 if key is less than 32 bytes\n * Hashes key if key is greater than 32 bytes\n */\nexport const createKey = (rawKey: string): WagmiBytes => {\n  if (rawKey.length < 32) {\n    return ethers.utils.formatBytes32String(rawKey) as WagmiBytes\n  }\n  const hash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(rawKey))\n  return (hash.slice(0, 64) + 'ff') as WagmiBytes\n}\n\n/**\n * @deprecated use createKey instead\n * Will be removed in v1.0.0\n */\nexport const encodeRawKey: typeof createKey = (rawKey) => {\n  console.warn('encodeRawKey is deprecated, use createKey instead')\n  return createKey(rawKey)\n}\n","import { Address } from '@wagmi/core'\nimport { BigNumber } from 'ethers'\nimport {\n  hexlify,\n  isAddress,\n  isHexString,\n  toUtf8Bytes,\n} from 'ethers/lib/utils.js'\n\nimport { WagmiBytes } from '../types/WagmiBytes'\n\n/**\n * Turns a value into bytes to make an attestation\n *\n * @example\n * createValue('hello world') // '0x68656c6c6f20776f726c64'\n * createValue(123) // '0x7b'\n * createValue(true) // '0x1'\n * createValue(BigNumber.from(10)) // '0xa'\n */\nexport const createValue = (\n  bytes: WagmiBytes | string | Address | number | boolean | BigNumber\n): WagmiBytes => {\n  bytes = bytes === '0x' ? '0x0' : bytes\n  if (BigNumber.isBigNumber(bytes)) {\n    return bytes.toHexString() as WagmiBytes\n  }\n  if (typeof bytes === 'number') {\n    return BigNumber.from(bytes).toHexString() as WagmiBytes\n  }\n  if (typeof bytes === 'boolean') {\n    return bytes ? '0x1' : '0x0'\n  }\n  if (isAddress(bytes)) {\n    return bytes\n  }\n  if (isHexString(bytes)) {\n    return bytes as WagmiBytes\n  }\n  if (typeof bytes === 'string') {\n    return hexlify(toUtf8Bytes(bytes)) as WagmiBytes\n  }\n  throw new Error(`unrecognized bytes type ${bytes satisfies never}`)\n}\n\n/**\n * @deprecated use createValue instead\n * Will be removed in v1.0.0\n */\nexport const stringifyAttestationBytes: typeof createValue = (bytes) => {\n  console.warn(\n    'stringifyAttestationBytes is deprecated, use createValue instead'\n  )\n  return createValue(bytes)\n}\n","import { readContracts } from '@wagmi/core'\nimport { formatBytes32String } from 'ethers/lib/utils.js'\n\nimport { ATTESTATION_STATION_ADDRESS } from '../constants/attestationStationAddress'\nimport type { AttestationReadParams } from '../types/AttestationReadParams'\nimport { DEFAULT_DATA_TYPE } from '../types/DataTypeOption'\nimport type { WagmiBytes } from '../types/WagmiBytes'\nimport { abi } from './abi'\nimport { parseAttestationBytes } from './parseAttestationBytes'\n\n/**\n * reads attestations from the attestation station contract\n *\n * @returns an array of attestation values\n * @throws Error if key is longer than 32 bytes\n * @example\n * const attestations = await readAttestations(\n *  {\n *    creator: creatorAddress,\n *    about: aboutAddress,\n *    key: 'my_key',\n *  },\n *  {\n *    creator: creatorAddress2,\n *    about: aboutAddress2,\n *    key: 'my_key',\n *    dataType: 'number',\n *    contractAddress: '0x1234',\n *   },\n * )\n */\nexport const readAttestations = async (\n  ...attestationReads: Array<AttestationReadParams>\n) => {\n  const calls = attestationReads.map((attestation) => {\n    const {\n      creator,\n      about,\n      key,\n      contractAddress = ATTESTATION_STATION_ADDRESS,\n    } = attestation\n    if (key.length > 32) {\n      throw new Error(\n        'Key is longer than the max length of 32 for attestation keys'\n      )\n    }\n    return {\n      address: contractAddress,\n      abi,\n      functionName: 'attestations',\n      args: [creator, about, formatBytes32String(key) as WagmiBytes],\n    } as const\n  })\n\n  const results = await readContracts({\n    contracts: calls,\n  })\n\n  return results.map((dataBytes, i) => {\n    const dataType = attestationReads[i].dataType ?? DEFAULT_DATA_TYPE\n    return parseAttestationBytes(dataBytes, dataType)\n  })\n}\n","import { z } from 'zod'\n\n/**\n * @internal\n * Default data type for attestations\n */\nexport const DEFAULT_DATA_TYPE = 'string' as const\n\n/**\n * Zod validator for the DataType type\n * string | bytes | number | bool | address\n */\nexport const dataTypeOptionValidator = z\n  .union([\n    z.literal('string'),\n    z.literal('bytes'),\n    z.literal('number'),\n    z.literal('bool'),\n    z.literal('address'),\n  ])\n  .optional()\n  .default('string').describe(`Zod validator for the DataType type\n string | bytes | number | bool | address`)\n\n/**\n * Options for attestation data type\n */\nexport type DataTypeOption = z.infer<typeof dataTypeOptionValidator>\n","/**\n * The attestation station abi\n */\nexport const abi = [\n  {\n    inputs: [],\n    stateMutability: 'nonpayable',\n    type: 'constructor',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'creator',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'about',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'key',\n        type: 'bytes32',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: 'val',\n        type: 'bytes',\n      },\n    ],\n    name: 'AttestationCreated',\n    type: 'event',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'address',\n            name: 'about',\n            type: 'address',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'key',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes',\n            name: 'val',\n            type: 'bytes',\n          },\n        ],\n        internalType: 'struct AttestationStation.AttestationData[]',\n        name: '_attestations',\n        type: 'tuple[]',\n      },\n    ],\n    name: 'attest',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_about',\n        type: 'address',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_key',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes',\n        name: '_val',\n        type: 'bytes',\n      },\n    ],\n    name: 'attest',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32',\n      },\n    ],\n    name: 'attestations',\n    outputs: [\n      {\n        internalType: 'bytes',\n        name: '',\n        type: 'bytes',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'version',\n    outputs: [\n      {\n        internalType: 'string',\n        name: '',\n        type: 'string',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n] as const\n","import { BigNumber } from 'ethers'\nimport { toUtf8String } from 'ethers/lib/utils.js'\nimport type { Address } from '@wagmi/core'\n\nimport type { DataTypeOption } from '../types/DataTypeOption'\nimport type { WagmiBytes } from '../types/WagmiBytes'\nimport { ParseBytesReturn } from '../types/ParseBytesReturn'\n\n/**\n * Parses a string attestion\n */\nexport const parseString = (rawAttestation: WagmiBytes): string => {\n  rawAttestation = rawAttestation === '0x0' ? '0x' : rawAttestation\n  return rawAttestation ? toUtf8String(rawAttestation) : ''\n}\n\n/**\n * Parses a boolean attestion\n */\nexport const parseBool = (rawAttestation: WagmiBytes): boolean => {\n  rawAttestation = rawAttestation === '0x' ? '0x0' : rawAttestation\n  return rawAttestation ? BigNumber.from(rawAttestation).gt(0) : false\n}\n\n/**\n * Parses a number attestion\n */\nexport const parseNumber = (rawAttestation: WagmiBytes): BigNumber => {\n  rawAttestation = rawAttestation === '0x' ? '0x0' : rawAttestation\n  return rawAttestation ? BigNumber.from(rawAttestation) : BigNumber.from(0)\n}\n\n/**\n * Parses a address attestion\n */\nexport const parseAddress = (rawAttestation: WagmiBytes): Address => {\n  rawAttestation = rawAttestation === '0x' ? '0x0' : rawAttestation\n  return rawAttestation\n    ? (BigNumber.from(rawAttestation).toHexString() as Address)\n    : '0x0000000000000000000000000000000000000000'\n}\n\n/**\n * @deprecated use parseString, parseBool, parseNumber, or parseAddress instead\n * Will be removed in v1.0.0\n * @internal\n * Parses a raw attestation\n */\nexport const parseAttestationBytes = <TDataType extends DataTypeOption>(\n  attestationBytes: WagmiBytes,\n  dataType: TDataType\n): ParseBytesReturn<TDataType> => {\n  if (dataType === 'bytes') {\n    return attestationBytes as ParseBytesReturn<TDataType>\n  }\n  if (dataType === 'number') {\n    return parseNumber(attestationBytes) as ParseBytesReturn<TDataType>\n  }\n  if (dataType === 'address') {\n    return parseAddress(attestationBytes) as ParseBytesReturn<TDataType>\n  }\n  if (dataType === 'bool') {\n    return parseBool(attestationBytes) as ParseBytesReturn<TDataType>\n  }\n  if (dataType === 'string') {\n    return parseString(attestationBytes) as ParseBytesReturn<TDataType>\n  }\n  console.warn(`unrecognized dataType ${dataType satisfies never}`)\n  return attestationBytes as never\n}\n","import type { Address } from '@wagmi/core'\nimport { BigNumber } from 'ethers'\n\nimport { DataTypeOption } from '../types/DataTypeOption'\nimport { ParseBytesReturn } from '../types/ParseBytesReturn'\nimport { readAttestations } from './readAttestations'\n\n/**\n * reads attestation from the attestation station contract\n *\n * @param attestationRead - the parameters for reading an attestation\n * @returns attestation result\n * @throws Error if key is longer than 32 bytes\n * @example\n * const attestation = await readAttestation(\n * {\n *  creator: creatorAddress,\n * about: aboutAddress,\n * key: 'my_key',\n * },\n */\nexport const readAttestation = async <TDataType extends DataTypeOption>(\n  /**\n   * Creator of the attestation\n   */\n  creator: Address,\n  /**\n   * Address the attestation is about\n   */\n  about: Address,\n  /**\n   * Key of the attestation\n   */\n  key: string,\n  /**\n   * Data type of the attestation\n   * string | bool | number | address | bytes\n   *\n   * @defaults 'string'\n   */\n  dataType: TDataType,\n  /**\n   * Attestation address\n   * defaults to the official Optimism attestation station determistic deploy address\n   *\n   * @defaults '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n   */\n  contractAddress: Address = '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n): Promise<ParseBytesReturn<TDataType>> => {\n  const [result] = await readAttestations({\n    creator,\n    about,\n    key,\n    contractAddress,\n    dataType,\n  })\n  return result as ParseBytesReturn<TDataType>\n}\n\n/**\n * Reads a string attestation\n */\nexport const readAttestationString = (\n  /**\n   * Creator of the attestation\n   */\n  creator: Address,\n  /**\n   * Address the attestation is about\n   */\n  about: Address,\n  /**\n   * Key of the attestation\n   */\n  key: string,\n  /**\n   * Attestation address\n   * defaults to the official Optimism attestation station determistic deploy address\n   *\n   * @defaults '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n   */\n  contractAddress: Address = '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n) => {\n  return readAttestation(\n    creator,\n    about,\n    key,\n    'string',\n    contractAddress\n  ) as Promise<string>\n}\n\nexport const readAttestationBool = (\n  /**\n   * Creator of the attestation\n   */\n  creator: Address,\n  /**\n   * Address the attestation is about\n   */\n  about: Address,\n  /**\n   * Key of the attestation\n   */\n  key: string,\n  /**\n   * Attestation address\n   * defaults to the official Optimism attestation station determistic deploy address\n   *\n   * @defaults '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n   */\n  contractAddress: Address = '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n) => {\n  return readAttestation(\n    /**\n     * Creator of the attestation\n     */\n    creator,\n    about,\n    key,\n    'bool',\n    contractAddress\n  ) as Promise<boolean>\n}\n\nexport const readAttestationNumber = (\n  /**\n   * Creator of the attestation\n   */\n  creator: Address,\n  /**\n   * Address the attestation is about\n   */\n  about: Address,\n  /**\n   * Key of the attestation\n   */\n  key: string,\n  /**\n   * Attestation address\n   * defaults to the official Optimism attestation station determistic deploy address\n   *\n   * @defaults '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n   */\n  contractAddress: Address = '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n) => {\n  return readAttestation(\n    creator,\n    about,\n    key,\n    'number',\n    contractAddress\n  ) as Promise<BigNumber>\n}\n\nexport const readAttestationAddress = (\n  /**\n   * Creator of the attestation\n   */\n  creator: Address,\n  /**\n   * Address the attestation is about\n   */\n  about: Address,\n  /**\n   * Key of the attestation\n   */\n  key: string,\n  /**\n   * Attestation address\n   * defaults to the official Optimism attestation station determistic deploy address\n   *\n   * @defaults '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n   */\n  contractAddress: Address = '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n) => {\n  return readAttestation(\n    creator,\n    about,\n    key,\n    'address',\n    contractAddress\n  ) as Promise<Address>\n}\n","import { ethers } from 'ethers'\nimport type { Address } from '@wagmi/core'\n\nimport { ATTESTATION_STATION_ADDRESS } from '../constants/attestationStationAddress'\nimport { abi } from '../lib/abi'\nimport { AttestationCreatedEvent } from '../types/AttestationCreatedEvent'\nimport { encodeRawKey } from './createKey'\n\nexport const getEvents = async ({\n  creator = null,\n  about = null,\n  key = null,\n  value = null,\n  provider,\n  fromBlockOrBlockhash,\n  toBlock,\n}: {\n  creator?: Address | null\n  about?: Address | null\n  key?: string | null\n  value?: string | null\n  provider: ethers.providers.JsonRpcProvider\n  fromBlockOrBlockhash?: ethers.providers.BlockTag | undefined\n  toBlock?: ethers.providers.BlockTag | undefined\n}) => {\n  const contract = new ethers.Contract(\n    ATTESTATION_STATION_ADDRESS,\n    abi,\n    provider\n  )\n  return contract.queryFilter(\n    contract.filters.AttestationCreated(\n      creator,\n      about,\n      key && encodeRawKey(key),\n      value\n    ),\n    fromBlockOrBlockhash,\n    toBlock\n  ) as Promise<AttestationCreatedEvent[]>\n}\n","import { Address, prepareWriteContract } from '@wagmi/core'\nimport { formatBytes32String } from 'ethers/lib/utils.js'\n\nimport { ATTESTATION_STATION_ADDRESS } from '../constants/attestationStationAddress'\nimport { WagmiBytes } from '../types/WagmiBytes'\nimport { abi } from './abi'\nimport { createValue } from './createValue'\n\nexport const prepareWriteAttestation = async (\n  about: Address,\n  key: string,\n  value: string | WagmiBytes | number | boolean,\n  chainId: number | undefined = undefined,\n  contractAddress: Address = ATTESTATION_STATION_ADDRESS\n) => {\n  let formattedKey: WagmiBytes\n  try {\n    formattedKey = formatBytes32String(key) as WagmiBytes\n  } catch (e) {\n    console.error(e)\n    throw new Error(\n      `key is longer than 32 bytes: ${key}.  Try using a shorter key or using 'encodeRawKey' to encode the key into 32 bytes first`\n    )\n  }\n  return prepareWriteContract({\n    address: contractAddress,\n    abi,\n    functionName: 'attest',\n    chainId,\n    args: [about, formattedKey, createValue(value) as WagmiBytes],\n  })\n}\n","import { Address, prepareWriteContract } from '@wagmi/core'\nimport { formatBytes32String } from 'ethers/lib/utils.js'\n\nimport { ATTESTATION_STATION_ADDRESS } from '../constants/attestationStationAddress'\nimport { WagmiBytes } from '../types/WagmiBytes'\nimport { abi } from './abi'\nimport { createValue } from './createValue'\n\ntype Attestation = {\n  about: Address\n  key: string\n  value: string | WagmiBytes | number | boolean\n}\n\nexport const prepareWriteAttestations = async (\n  attestations: Attestation[],\n  chainId: number | undefined = undefined,\n  contractAddress: Address = ATTESTATION_STATION_ADDRESS\n) => {\n  const formattedAttestations = attestations.map((attestation) => {\n    let formattedKey: WagmiBytes\n    try {\n      formattedKey = formatBytes32String(attestation.key) as WagmiBytes\n    } catch (e) {\n      console.error(e)\n      throw new Error(\n        `key is longer than 32 bytes: ${attestation.key}.  Try using a shorter key or using 'encodeRawKey' to encode the key into 32 bytes first`\n      )\n    }\n    const formattedValue = createValue(attestation.value) as WagmiBytes\n    return {\n      about: attestation.about,\n      key: formattedKey,\n      val: formattedValue,\n    } as const\n  })\n  return prepareWriteContract({\n    address: contractAddress,\n    abi,\n    functionName: 'attest',\n    chainId,\n    args: [formattedAttestations],\n  })\n}\n","import { writeContract } from '@wagmi/core'\nexport { prepareWriteAttestation } from './prepareWriteAttestation'\n\nexport { abi } from './abi'\n\n/**\n * Writes an attestation to the blockchain\n * Same function as `writeContract` from @wagmi/core\n * To use first use prepareWriteContract\n *\n * @example\n * const config = await prepareAttestation(about, key, value)\n * const tx = await writeAttestation(config)\n */\nexport const writeAttestation = writeContract\n"],"mappings":"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","names":["import_ethers","import_utils","import_ethers","import_utils","import_ethers","import_core","import_utils","import_core","import_utils","import_core"]}