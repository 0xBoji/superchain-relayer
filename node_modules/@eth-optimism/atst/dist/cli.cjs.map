{"version":3,"sources":["../src/lib/logger.ts","../src/types/DataTypeOption.ts","../src/constants/attestationStationAddress.ts","../src/constants/defaultRpcUrl.ts","../src/lib/abi.ts","../src/lib/parseAttestationBytes.ts","../src/lib/readAttestations.ts","../src/lib/readAttestation.ts","../src/commands/read.ts","../src/lib/createValue.ts","../src/lib/prepareWriteAttestation.ts","../src/lib/writeAttestation.ts","../src/lib/castAsDataType.ts","../src/commands/write.ts","../src/cli.ts"],"sourcesContent":["import util from 'util'\n\nimport ora from 'ora'\nimport pc from 'picocolors'\n\nconst format = (args: any[]) => {\n  return util\n    .format(...args)\n    .split('\\n')\n    .join('\\n')\n}\n\nexport const success = (...args: Array<any>) => {\n  console.log(pc.green(format(args)))\n}\n\nexport const info = (...args: Array<any>) => {\n  console.info(pc.blue(format(args)))\n}\n\nexport const log = (...args: Array<any>) => {\n  console.log(pc.white(format(args)))\n}\n\nexport const warn = (...args: Array<any>) => {\n  console.warn(pc.yellow(format(args)))\n}\n\nexport const error = (...args: Array<any>) => {\n  console.error(pc.red(format(args)))\n}\n\nexport const spinner = () => {\n  return ora({\n    color: 'gray',\n    spinner: 'dots8Bit',\n  })\n}\n","import { z } from 'zod'\n\n/**\n * @internal\n * Default data type for attestations\n */\nexport const DEFAULT_DATA_TYPE = 'string' as const\n\n/**\n * Zod validator for the DataType type\n * string | bytes | number | bool | address\n */\nexport const dataTypeOptionValidator = z\n  .union([\n    z.literal('string'),\n    z.literal('bytes'),\n    z.literal('number'),\n    z.literal('bool'),\n    z.literal('address'),\n  ])\n  .optional()\n  .default('string').describe(`Zod validator for the DataType type\n string | bytes | number | bool | address`)\n\n/**\n * Options for attestation data type\n */\nexport type DataTypeOption = z.infer<typeof dataTypeOptionValidator>\n","/**\n * The attestation station contract address\n * The attestation station contract is deterministically deployed\n * to 0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77\n */\nexport const ATTESTATION_STATION_ADDRESS =\n  '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n","/**\n * @internal\n * Default RPC URL for Optimism\n */\nexport const DEFAULT_RPC_URL = 'https://mainnet.optimism.io'\n","/**\n * The attestation station abi\n */\nexport const abi = [\n  {\n    inputs: [],\n    stateMutability: 'nonpayable',\n    type: 'constructor',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'creator',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'about',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'bytes32',\n        name: 'key',\n        type: 'bytes32',\n      },\n      {\n        indexed: false,\n        internalType: 'bytes',\n        name: 'val',\n        type: 'bytes',\n      },\n    ],\n    name: 'AttestationCreated',\n    type: 'event',\n  },\n  {\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'address',\n            name: 'about',\n            type: 'address',\n          },\n          {\n            internalType: 'bytes32',\n            name: 'key',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'bytes',\n            name: 'val',\n            type: 'bytes',\n          },\n        ],\n        internalType: 'struct AttestationStation.AttestationData[]',\n        name: '_attestations',\n        type: 'tuple[]',\n      },\n    ],\n    name: 'attest',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '_about',\n        type: 'address',\n      },\n      {\n        internalType: 'bytes32',\n        name: '_key',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'bytes',\n        name: '_val',\n        type: 'bytes',\n      },\n    ],\n    name: 'attest',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32',\n      },\n    ],\n    name: 'attestations',\n    outputs: [\n      {\n        internalType: 'bytes',\n        name: '',\n        type: 'bytes',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'version',\n    outputs: [\n      {\n        internalType: 'string',\n        name: '',\n        type: 'string',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n] as const\n","import { BigNumber } from 'ethers'\nimport { toUtf8String } from 'ethers/lib/utils.js'\nimport type { Address } from '@wagmi/core'\n\nimport type { DataTypeOption } from '../types/DataTypeOption'\nimport type { WagmiBytes } from '../types/WagmiBytes'\nimport { ParseBytesReturn } from '../types/ParseBytesReturn'\n\n/**\n * Parses a string attestion\n */\nexport const parseString = (rawAttestation: WagmiBytes): string => {\n  rawAttestation = rawAttestation === '0x0' ? '0x' : rawAttestation\n  return rawAttestation ? toUtf8String(rawAttestation) : ''\n}\n\n/**\n * Parses a boolean attestion\n */\nexport const parseBool = (rawAttestation: WagmiBytes): boolean => {\n  rawAttestation = rawAttestation === '0x' ? '0x0' : rawAttestation\n  return rawAttestation ? BigNumber.from(rawAttestation).gt(0) : false\n}\n\n/**\n * Parses a number attestion\n */\nexport const parseNumber = (rawAttestation: WagmiBytes): BigNumber => {\n  rawAttestation = rawAttestation === '0x' ? '0x0' : rawAttestation\n  return rawAttestation ? BigNumber.from(rawAttestation) : BigNumber.from(0)\n}\n\n/**\n * Parses a address attestion\n */\nexport const parseAddress = (rawAttestation: WagmiBytes): Address => {\n  rawAttestation = rawAttestation === '0x' ? '0x0' : rawAttestation\n  return rawAttestation\n    ? (BigNumber.from(rawAttestation).toHexString() as Address)\n    : '0x0000000000000000000000000000000000000000'\n}\n\n/**\n * @deprecated use parseString, parseBool, parseNumber, or parseAddress instead\n * Will be removed in v1.0.0\n * @internal\n * Parses a raw attestation\n */\nexport const parseAttestationBytes = <TDataType extends DataTypeOption>(\n  attestationBytes: WagmiBytes,\n  dataType: TDataType\n): ParseBytesReturn<TDataType> => {\n  if (dataType === 'bytes') {\n    return attestationBytes as ParseBytesReturn<TDataType>\n  }\n  if (dataType === 'number') {\n    return parseNumber(attestationBytes) as ParseBytesReturn<TDataType>\n  }\n  if (dataType === 'address') {\n    return parseAddress(attestationBytes) as ParseBytesReturn<TDataType>\n  }\n  if (dataType === 'bool') {\n    return parseBool(attestationBytes) as ParseBytesReturn<TDataType>\n  }\n  if (dataType === 'string') {\n    return parseString(attestationBytes) as ParseBytesReturn<TDataType>\n  }\n  console.warn(`unrecognized dataType ${dataType satisfies never}`)\n  return attestationBytes as never\n}\n","import { readContracts } from '@wagmi/core'\nimport { formatBytes32String } from 'ethers/lib/utils.js'\n\nimport { ATTESTATION_STATION_ADDRESS } from '../constants/attestationStationAddress'\nimport type { AttestationReadParams } from '../types/AttestationReadParams'\nimport { DEFAULT_DATA_TYPE } from '../types/DataTypeOption'\nimport type { WagmiBytes } from '../types/WagmiBytes'\nimport { abi } from './abi'\nimport { parseAttestationBytes } from './parseAttestationBytes'\n\n/**\n * reads attestations from the attestation station contract\n *\n * @returns an array of attestation values\n * @throws Error if key is longer than 32 bytes\n * @example\n * const attestations = await readAttestations(\n *  {\n *    creator: creatorAddress,\n *    about: aboutAddress,\n *    key: 'my_key',\n *  },\n *  {\n *    creator: creatorAddress2,\n *    about: aboutAddress2,\n *    key: 'my_key',\n *    dataType: 'number',\n *    contractAddress: '0x1234',\n *   },\n * )\n */\nexport const readAttestations = async (\n  ...attestationReads: Array<AttestationReadParams>\n) => {\n  const calls = attestationReads.map((attestation) => {\n    const {\n      creator,\n      about,\n      key,\n      contractAddress = ATTESTATION_STATION_ADDRESS,\n    } = attestation\n    if (key.length > 32) {\n      throw new Error(\n        'Key is longer than the max length of 32 for attestation keys'\n      )\n    }\n    return {\n      address: contractAddress,\n      abi,\n      functionName: 'attestations',\n      args: [creator, about, formatBytes32String(key) as WagmiBytes],\n    } as const\n  })\n\n  const results = await readContracts({\n    contracts: calls,\n  })\n\n  return results.map((dataBytes, i) => {\n    const dataType = attestationReads[i].dataType ?? DEFAULT_DATA_TYPE\n    return parseAttestationBytes(dataBytes, dataType)\n  })\n}\n","import type { Address } from '@wagmi/core'\nimport { BigNumber } from 'ethers'\n\nimport { DataTypeOption } from '../types/DataTypeOption'\nimport { ParseBytesReturn } from '../types/ParseBytesReturn'\nimport { readAttestations } from './readAttestations'\n\n/**\n * reads attestation from the attestation station contract\n *\n * @param attestationRead - the parameters for reading an attestation\n * @returns attestation result\n * @throws Error if key is longer than 32 bytes\n * @example\n * const attestation = await readAttestation(\n * {\n *  creator: creatorAddress,\n * about: aboutAddress,\n * key: 'my_key',\n * },\n */\nexport const readAttestation = async <TDataType extends DataTypeOption>(\n  /**\n   * Creator of the attestation\n   */\n  creator: Address,\n  /**\n   * Address the attestation is about\n   */\n  about: Address,\n  /**\n   * Key of the attestation\n   */\n  key: string,\n  /**\n   * Data type of the attestation\n   * string | bool | number | address | bytes\n   *\n   * @defaults 'string'\n   */\n  dataType: TDataType,\n  /**\n   * Attestation address\n   * defaults to the official Optimism attestation station determistic deploy address\n   *\n   * @defaults '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n   */\n  contractAddress: Address = '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n): Promise<ParseBytesReturn<TDataType>> => {\n  const [result] = await readAttestations({\n    creator,\n    about,\n    key,\n    contractAddress,\n    dataType,\n  })\n  return result as ParseBytesReturn<TDataType>\n}\n\n/**\n * Reads a string attestation\n */\nexport const readAttestationString = (\n  /**\n   * Creator of the attestation\n   */\n  creator: Address,\n  /**\n   * Address the attestation is about\n   */\n  about: Address,\n  /**\n   * Key of the attestation\n   */\n  key: string,\n  /**\n   * Attestation address\n   * defaults to the official Optimism attestation station determistic deploy address\n   *\n   * @defaults '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n   */\n  contractAddress: Address = '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n) => {\n  return readAttestation(\n    creator,\n    about,\n    key,\n    'string',\n    contractAddress\n  ) as Promise<string>\n}\n\nexport const readAttestationBool = (\n  /**\n   * Creator of the attestation\n   */\n  creator: Address,\n  /**\n   * Address the attestation is about\n   */\n  about: Address,\n  /**\n   * Key of the attestation\n   */\n  key: string,\n  /**\n   * Attestation address\n   * defaults to the official Optimism attestation station determistic deploy address\n   *\n   * @defaults '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n   */\n  contractAddress: Address = '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n) => {\n  return readAttestation(\n    /**\n     * Creator of the attestation\n     */\n    creator,\n    about,\n    key,\n    'bool',\n    contractAddress\n  ) as Promise<boolean>\n}\n\nexport const readAttestationNumber = (\n  /**\n   * Creator of the attestation\n   */\n  creator: Address,\n  /**\n   * Address the attestation is about\n   */\n  about: Address,\n  /**\n   * Key of the attestation\n   */\n  key: string,\n  /**\n   * Attestation address\n   * defaults to the official Optimism attestation station determistic deploy address\n   *\n   * @defaults '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n   */\n  contractAddress: Address = '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n) => {\n  return readAttestation(\n    creator,\n    about,\n    key,\n    'number',\n    contractAddress\n  ) as Promise<BigNumber>\n}\n\nexport const readAttestationAddress = (\n  /**\n   * Creator of the attestation\n   */\n  creator: Address,\n  /**\n   * Address the attestation is about\n   */\n  about: Address,\n  /**\n   * Key of the attestation\n   */\n  key: string,\n  /**\n   * Attestation address\n   * defaults to the official Optimism attestation station determistic deploy address\n   *\n   * @defaults '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n   */\n  contractAddress: Address = '0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77'\n) => {\n  return readAttestation(\n    creator,\n    about,\n    key,\n    'address',\n    contractAddress\n  ) as Promise<Address>\n}\n","import { Address, createClient } from '@wagmi/core'\nimport { isAddress } from 'ethers/lib/utils.js'\nimport { z } from 'zod'\nimport { providers } from 'ethers'\n\nimport * as logger from '../lib/logger'\nimport { dataTypeOptionValidator } from '../types/DataTypeOption'\nimport type { WagmiBytes } from '../types/WagmiBytes'\nimport { ATTESTATION_STATION_ADDRESS } from '../constants/attestationStationAddress'\nimport { DEFAULT_RPC_URL } from '../constants/defaultRpcUrl'\nimport { readAttestation } from '../lib/readAttestation'\n\nconst zodAddress = () =>\n  z\n    .string()\n    .transform((addr) => addr as Address)\n    .refine(isAddress, { message: 'Invalid address' })\n\nexport const readOptionsValidators = {\n  creator: zodAddress().describe('Address of the creator of the attestation'),\n  about: zodAddress().describe('Address of the subject of the attestation'),\n  key: z\n    .string()\n    .describe('Key of the attestation either as string or hex number'),\n  dataType: dataTypeOptionValidator,\n  rpcUrl: z\n    .string()\n    .url()\n    .optional()\n    .default(DEFAULT_RPC_URL)\n    .describe('Rpc url to use'),\n  contract: zodAddress()\n    .optional()\n    .default(ATTESTATION_STATION_ADDRESS)\n    .describe('Contract address to read from'),\n}\nconst validators = z.object(readOptionsValidators)\n\nexport type ReadOptions = z.infer<typeof validators>\n\nexport const read = async (options: ReadOptions) => {\n  // TODO make these errors more user friendly\n  const parsedOptions = await validators.parseAsync(options).catch((e) => {\n    logger.error(e)\n    process.exit(1)\n  })\n\n  const provider = new providers.JsonRpcProvider({\n    url: parsedOptions.rpcUrl,\n    headers: {\n      'User-Agent': '@eth-optimism/atst',\n    },\n  })\n\n  createClient({\n    provider,\n  })\n\n  try {\n    const result = await readAttestation(\n      parsedOptions.creator,\n      parsedOptions.about,\n      parsedOptions.key as WagmiBytes,\n      parsedOptions.dataType,\n      parsedOptions.contract\n    )\n    logger.log(result?.toString())\n    return result?.toString()\n  } catch (e) {\n    logger.error('Unable to read attestation', e)\n    process.exit(1)\n  }\n}\n","import { Address } from '@wagmi/core'\nimport { BigNumber } from 'ethers'\nimport {\n  hexlify,\n  isAddress,\n  isHexString,\n  toUtf8Bytes,\n} from 'ethers/lib/utils.js'\n\nimport { WagmiBytes } from '../types/WagmiBytes'\n\n/**\n * Turns a value into bytes to make an attestation\n *\n * @example\n * createValue('hello world') // '0x68656c6c6f20776f726c64'\n * createValue(123) // '0x7b'\n * createValue(true) // '0x1'\n * createValue(BigNumber.from(10)) // '0xa'\n */\nexport const createValue = (\n  bytes: WagmiBytes | string | Address | number | boolean | BigNumber\n): WagmiBytes => {\n  bytes = bytes === '0x' ? '0x0' : bytes\n  if (BigNumber.isBigNumber(bytes)) {\n    return bytes.toHexString() as WagmiBytes\n  }\n  if (typeof bytes === 'number') {\n    return BigNumber.from(bytes).toHexString() as WagmiBytes\n  }\n  if (typeof bytes === 'boolean') {\n    return bytes ? '0x1' : '0x0'\n  }\n  if (isAddress(bytes)) {\n    return bytes\n  }\n  if (isHexString(bytes)) {\n    return bytes as WagmiBytes\n  }\n  if (typeof bytes === 'string') {\n    return hexlify(toUtf8Bytes(bytes)) as WagmiBytes\n  }\n  throw new Error(`unrecognized bytes type ${bytes satisfies never}`)\n}\n\n/**\n * @deprecated use createValue instead\n * Will be removed in v1.0.0\n */\nexport const stringifyAttestationBytes: typeof createValue = (bytes) => {\n  console.warn(\n    'stringifyAttestationBytes is deprecated, use createValue instead'\n  )\n  return createValue(bytes)\n}\n","import { Address, prepareWriteContract } from '@wagmi/core'\nimport { formatBytes32String } from 'ethers/lib/utils.js'\n\nimport { ATTESTATION_STATION_ADDRESS } from '../constants/attestationStationAddress'\nimport { WagmiBytes } from '../types/WagmiBytes'\nimport { abi } from './abi'\nimport { createValue } from './createValue'\n\nexport const prepareWriteAttestation = async (\n  about: Address,\n  key: string,\n  value: string | WagmiBytes | number | boolean,\n  chainId: number | undefined = undefined,\n  contractAddress: Address = ATTESTATION_STATION_ADDRESS\n) => {\n  let formattedKey: WagmiBytes\n  try {\n    formattedKey = formatBytes32String(key) as WagmiBytes\n  } catch (e) {\n    console.error(e)\n    throw new Error(\n      `key is longer than 32 bytes: ${key}.  Try using a shorter key or using 'encodeRawKey' to encode the key into 32 bytes first`\n    )\n  }\n  return prepareWriteContract({\n    address: contractAddress,\n    abi,\n    functionName: 'attest',\n    chainId,\n    args: [about, formattedKey, createValue(value) as WagmiBytes],\n  })\n}\n","import { writeContract } from '@wagmi/core'\nexport { prepareWriteAttestation } from './prepareWriteAttestation'\n\nexport { abi } from './abi'\n\n/**\n * Writes an attestation to the blockchain\n * Same function as `writeContract` from @wagmi/core\n * To use first use prepareWriteContract\n *\n * @example\n * const config = await prepareAttestation(about, key, value)\n * const tx = await writeAttestation(config)\n */\nexport const writeAttestation = writeContract\n","import { DataTypeOption } from '../types/DataTypeOption'\n\n/**\n * @internal\n * Takes a datatype and returns the value casted to that type\n */\nexport const castAsDataType = (value: any, dataType: DataTypeOption) => {\n  if (dataType === 'string') {\n    return value\n  } else if (dataType === 'number') {\n    return Number(value)\n  } else if (dataType === 'bool') {\n    return Boolean(value)\n  } else if (dataType === 'bytes') {\n    return value\n  } else if (dataType === 'address') {\n    return value\n  } else {\n    throw new Error(`Unrecognized data type ${dataType satisfies never}`)\n  }\n}\n","import { Address, connect, createClient } from '@wagmi/core'\nimport { isAddress } from 'ethers/lib/utils.js'\nimport { z } from 'zod'\nimport { providers, Wallet } from 'ethers'\nimport { MockConnector } from '@wagmi/core/connectors/mock'\n\nimport * as logger from '../lib/logger'\nimport { ATTESTATION_STATION_ADDRESS } from '../constants/attestationStationAddress'\nimport { DEFAULT_RPC_URL } from '../constants/defaultRpcUrl'\nimport { prepareWriteAttestation } from '../lib/prepareWriteAttestation'\nimport { writeAttestation } from '../lib/writeAttestation'\nimport { castAsDataType } from '../lib/castAsDataType'\nimport { dataTypeOptionValidator } from '../types/DataTypeOption'\n\nconst zodAddress = () =>\n  z\n    .string()\n    .transform((addr) => addr as Address)\n    .refine(isAddress, { message: 'Invalid address' })\n\nconst zodWallet = () => z.string().refine((key) => new Wallet(key))\n\nconst zodAttestation = () => z.union([z.string(), z.number(), z.boolean()])\n\nexport const writeOptionsValidators = {\n  privateKey: zodWallet().describe('Address of the creator of the attestation'),\n  about: zodAddress().describe('Address of the subject of the attestation'),\n  key: z\n    .string()\n    .describe('Key of the attestation either as string or hex number'),\n  value: zodAttestation().describe('Attestation value').default(''),\n  dataType: dataTypeOptionValidator,\n  rpcUrl: z\n    .string()\n    .url()\n    .optional()\n    .default(DEFAULT_RPC_URL)\n    .describe('Rpc url to use'),\n  contract: zodAddress()\n    .optional()\n    .default(ATTESTATION_STATION_ADDRESS)\n    .describe('Contract address to read from'),\n}\nconst validators = z.object(writeOptionsValidators)\n\nexport type WriteOptions = z.infer<typeof validators>\n\nexport const write = async (options: WriteOptions) => {\n  // TODO make these errors more user friendly\n  const parsedOptions = await validators.parseAsync(options).catch((e) => {\n    logger.error(e)\n    process.exit(1)\n  })\n\n  const provider = new providers.JsonRpcProvider({\n    url: parsedOptions.rpcUrl,\n    headers: {\n      'User-Agent': '@eth-optimism/atst',\n    },\n  })\n\n  createClient({\n    provider,\n  })\n\n  const network = await provider.getNetwork()\n\n  if (!network) {\n    logger.error('Unable to detect chainId')\n    process.exit(1)\n  }\n\n  await connect({\n    // MockConnector is actually a vanilla connector\n    // it's called mockConnector because normally they\n    // expect us to connect with metamask or something\n    // but we're just using a private key\n    connector: new MockConnector({\n      options: {\n        chainId: network.chainId,\n        signer: new Wallet(parsedOptions.privateKey, provider),\n      },\n    }),\n  })\n\n  try {\n    const preparedTx = await prepareWriteAttestation(\n      parsedOptions.about,\n      parsedOptions.key,\n      castAsDataType(parsedOptions.value, parsedOptions.dataType),\n      network.chainId\n    )\n    const result = await writeAttestation(preparedTx)\n    await result.wait()\n    logger.log(`txHash: ${result.hash}`)\n    return result.hash\n  } catch (e) {\n    logger.error('Unable to read attestation', e)\n    process.exit(1)\n  }\n}\n","#!/usr/bin/env node\nimport { cac } from 'cac'\nimport type { Address } from '@wagmi/core'\n\nimport { readOptionsValidators, ReadOptions } from './commands/read'\nimport * as logger from './lib/logger'\n// @ts-ignore it's mad about me importing something not in tsconfig.includes\nimport packageJson from '../package.json'\nimport { WriteOptions, writeOptionsValidators } from './commands/write'\n\nconst cli = cac('atst')\n\ncli\n  .command('read', 'read an attestation')\n  .option('--creator <string>', readOptionsValidators.creator.description!)\n  .option('--about <string>', readOptionsValidators.about.description!)\n  .option('--key <string>', readOptionsValidators.key.description!)\n  .option('--data-type <string>', readOptionsValidators.dataType.description!, {\n    default: readOptionsValidators.dataType.parse(undefined),\n  })\n  .option('--rpc-url <url>', readOptionsValidators.rpcUrl.description!, {\n    default: readOptionsValidators.rpcUrl.parse(undefined),\n  })\n  .option('--contract <address>', readOptionsValidators.contract.description!, {\n    default: readOptionsValidators.contract.parse(undefined),\n  })\n  .example(\n    () =>\n      // note: private key is just the first testing address when running anvil\n      `atst read --key \"optimist.base-uri\" --about 0x2335022c740d17c2837f9C884Bfe4fFdbf0A95D5 --creator 0x60c5C9c98bcBd0b0F2fD89B24c16e533BaA8CdA3`\n  )\n  .action(async (options: ReadOptions) => {\n    const { read } = await import('./commands/read')\n\n    // TODO use the native api to do this instead of parsing the raw args\n    // by default options parses addresses as numbers without precision\n    // we should use the args parsing library to do this directly\n    // but for now I didn't bother to figure out how to do that\n    const { rawArgs } = cli\n    const about = rawArgs[rawArgs.indexOf('--about') + 1] as Address\n    const creator = rawArgs[rawArgs.indexOf('--creator') + 1] as Address\n    const contract = rawArgs.includes('--contract')\n      ? (rawArgs[rawArgs.indexOf('--contract') + 1] as Address)\n      : options.contract\n\n    await read({ ...options, about, creator, contract })\n  })\n\ncli\n  .command('write', 'write an attestation')\n  .option(\n    '--private-key <string>',\n    writeOptionsValidators.privateKey.description!\n  )\n  .option('--data-type <string>', readOptionsValidators.dataType.description!, {\n    default: writeOptionsValidators.dataType.parse(undefined),\n  })\n  .option('--about <string>', writeOptionsValidators.about.description!)\n  .option('--key <string>', writeOptionsValidators.key.description!)\n  .option('--value <string>', writeOptionsValidators.value.description!)\n  .option('--rpc-url <url>', writeOptionsValidators.rpcUrl.description!, {\n    default: writeOptionsValidators.rpcUrl.parse(undefined),\n  })\n  .option(\n    '--contract <address>',\n    writeOptionsValidators.contract.description!,\n    {\n      default: writeOptionsValidators.contract.parse(undefined),\n    }\n  )\n  .example(\n    () =>\n      `atst write --key \"optimist.base-uri\" --about 0x2335022c740d17c2837f9C884Bfe4fFdbf0A95D5 --value \"my attestation\" --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 --rpc-url http://localhost:8545`\n  )\n  .action(async (options: WriteOptions) => {\n    const spinner = logger.spinner()\n    spinner.start('Writing attestation...')\n    const { write } = await import('./commands/write')\n\n    // TODO use the native api to do this instead of parsing the raw args\n    // by default options parses addresses as numbers without precision\n    // we should use the args parsing library to do this directly\n    // but for now I didn't bother to figure out how to do that\n    const { rawArgs } = cli\n    const privateKey = rawArgs[rawArgs.indexOf('--private-key') + 1] as Address\n    const about = rawArgs[rawArgs.indexOf('--about') + 1] as Address\n    const contract = rawArgs.includes('--contract')\n      ? (rawArgs[rawArgs.indexOf('--contract') + 1] as Address)\n      : options.contract\n\n    await write({ ...options, about, privateKey, contract })\n      .then((res) => {\n        spinner.succeed('Attestation written!')\n        logger.info(`Attestation hash: ${res}`)\n      })\n      .catch((e) => {\n        logger.error(e)\n        spinner.fail('Attestation failed!')\n      })\n  })\n\ncli.version(packageJson.version)\n\nvoid (async () => {\n  try {\n    // Parse CLI args without running command\n    cli.parse(process.argv, { run: false })\n    if (!cli.matchedCommand && cli.args.length === 0) {\n      cli.outputHelp()\n    }\n    await cli.runMatchedCommand()\n  } catch (error) {\n    logger.error(`\\n${(error as Error).message}`)\n    process.exit(1)\n  }\n})()\n"],"mappings":"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","names":["util","pc","ora","import_utils","import_core","import_utils","import_zod","import_ethers","import_ethers","import_utils","import_core","import_utils","import_core","import_core","import_utils","import_zod","import_ethers","zodAddress","validators","read","spinner","write","error"]}