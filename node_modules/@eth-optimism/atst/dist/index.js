// src/constants/attestationStationAddress.ts
var ATTESTATION_STATION_ADDRESS = "0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77";

// src/lib/createKey.ts
import { ethers } from "ethers";
var createKey = (rawKey) => {
  if (rawKey.length < 32) {
    return ethers.utils.formatBytes32String(rawKey);
  }
  const hash = ethers.utils.keccak256(ethers.utils.toUtf8Bytes(rawKey));
  return hash.slice(0, 64) + "ff";
};
var encodeRawKey = (rawKey) => {
  console.warn("encodeRawKey is deprecated, use createKey instead");
  return createKey(rawKey);
};

// src/lib/createValue.ts
import { BigNumber } from "ethers";
import {
  hexlify,
  isAddress,
  isHexString,
  toUtf8Bytes
} from "ethers/lib/utils.js";
var createValue = (bytes) => {
  bytes = bytes === "0x" ? "0x0" : bytes;
  if (BigNumber.isBigNumber(bytes)) {
    return bytes.toHexString();
  }
  if (typeof bytes === "number") {
    return BigNumber.from(bytes).toHexString();
  }
  if (typeof bytes === "boolean") {
    return bytes ? "0x1" : "0x0";
  }
  if (isAddress(bytes)) {
    return bytes;
  }
  if (isHexString(bytes)) {
    return bytes;
  }
  if (typeof bytes === "string") {
    return hexlify(toUtf8Bytes(bytes));
  }
  throw new Error(`unrecognized bytes type ${bytes}`);
};
var stringifyAttestationBytes = (bytes) => {
  console.warn(
    "stringifyAttestationBytes is deprecated, use createValue instead"
  );
  return createValue(bytes);
};

// src/lib/readAttestations.ts
import { readContracts } from "@wagmi/core";
import { formatBytes32String } from "ethers/lib/utils.js";

// src/types/DataTypeOption.ts
import { z } from "zod";
var DEFAULT_DATA_TYPE = "string";
var dataTypeOptionValidator = z.union([
  z.literal("string"),
  z.literal("bytes"),
  z.literal("number"),
  z.literal("bool"),
  z.literal("address")
]).optional().default("string").describe(`Zod validator for the DataType type
 string | bytes | number | bool | address`);

// src/lib/abi.ts
var abi = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "about",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "key",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "val",
        type: "bytes"
      }
    ],
    name: "AttestationCreated",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "about",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "key",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "val",
            type: "bytes"
          }
        ],
        internalType: "struct AttestationStation.AttestationData[]",
        name: "_attestations",
        type: "tuple[]"
      }
    ],
    name: "attest",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_about",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_val",
        type: "bytes"
      }
    ],
    name: "attest",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "attestations",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/lib/parseAttestationBytes.ts
import { BigNumber as BigNumber2 } from "ethers";
import { toUtf8String } from "ethers/lib/utils.js";
var parseString = (rawAttestation) => {
  rawAttestation = rawAttestation === "0x0" ? "0x" : rawAttestation;
  return rawAttestation ? toUtf8String(rawAttestation) : "";
};
var parseBool = (rawAttestation) => {
  rawAttestation = rawAttestation === "0x" ? "0x0" : rawAttestation;
  return rawAttestation ? BigNumber2.from(rawAttestation).gt(0) : false;
};
var parseNumber = (rawAttestation) => {
  rawAttestation = rawAttestation === "0x" ? "0x0" : rawAttestation;
  return rawAttestation ? BigNumber2.from(rawAttestation) : BigNumber2.from(0);
};
var parseAddress = (rawAttestation) => {
  rawAttestation = rawAttestation === "0x" ? "0x0" : rawAttestation;
  return rawAttestation ? BigNumber2.from(rawAttestation).toHexString() : "0x0000000000000000000000000000000000000000";
};
var parseAttestationBytes = (attestationBytes, dataType) => {
  if (dataType === "bytes") {
    return attestationBytes;
  }
  if (dataType === "number") {
    return parseNumber(attestationBytes);
  }
  if (dataType === "address") {
    return parseAddress(attestationBytes);
  }
  if (dataType === "bool") {
    return parseBool(attestationBytes);
  }
  if (dataType === "string") {
    return parseString(attestationBytes);
  }
  console.warn(`unrecognized dataType ${dataType}`);
  return attestationBytes;
};

// src/lib/readAttestations.ts
var readAttestations = async (...attestationReads) => {
  const calls = attestationReads.map((attestation) => {
    const {
      creator,
      about,
      key,
      contractAddress = ATTESTATION_STATION_ADDRESS
    } = attestation;
    if (key.length > 32) {
      throw new Error(
        "Key is longer than the max length of 32 for attestation keys"
      );
    }
    return {
      address: contractAddress,
      abi,
      functionName: "attestations",
      args: [creator, about, formatBytes32String(key)]
    };
  });
  const results = await readContracts({
    contracts: calls
  });
  return results.map((dataBytes, i) => {
    const dataType = attestationReads[i].dataType ?? DEFAULT_DATA_TYPE;
    return parseAttestationBytes(dataBytes, dataType);
  });
};

// src/lib/readAttestation.ts
var readAttestation = async (creator, about, key, dataType, contractAddress = "0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77") => {
  const [result] = await readAttestations({
    creator,
    about,
    key,
    contractAddress,
    dataType
  });
  return result;
};
var readAttestationString = (creator, about, key, contractAddress = "0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77") => {
  return readAttestation(
    creator,
    about,
    key,
    "string",
    contractAddress
  );
};
var readAttestationBool = (creator, about, key, contractAddress = "0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77") => {
  return readAttestation(
    creator,
    about,
    key,
    "bool",
    contractAddress
  );
};
var readAttestationNumber = (creator, about, key, contractAddress = "0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77") => {
  return readAttestation(
    creator,
    about,
    key,
    "number",
    contractAddress
  );
};
var readAttestationAddress = (creator, about, key, contractAddress = "0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77") => {
  return readAttestation(
    creator,
    about,
    key,
    "address",
    contractAddress
  );
};

// src/lib/getEvents.ts
import { ethers as ethers2 } from "ethers";
var getEvents = async ({
  creator = null,
  about = null,
  key = null,
  value = null,
  provider,
  fromBlockOrBlockhash,
  toBlock
}) => {
  const contract = new ethers2.Contract(
    ATTESTATION_STATION_ADDRESS,
    abi,
    provider
  );
  return contract.queryFilter(
    contract.filters.AttestationCreated(
      creator,
      about,
      key && encodeRawKey(key),
      value
    ),
    fromBlockOrBlockhash,
    toBlock
  );
};

// src/lib/prepareWriteAttestation.ts
import { prepareWriteContract } from "@wagmi/core";
import { formatBytes32String as formatBytes32String2 } from "ethers/lib/utils.js";
var prepareWriteAttestation = async (about, key, value, chainId = void 0, contractAddress = ATTESTATION_STATION_ADDRESS) => {
  let formattedKey;
  try {
    formattedKey = formatBytes32String2(key);
  } catch (e) {
    console.error(e);
    throw new Error(
      `key is longer than 32 bytes: ${key}.  Try using a shorter key or using 'encodeRawKey' to encode the key into 32 bytes first`
    );
  }
  return prepareWriteContract({
    address: contractAddress,
    abi,
    functionName: "attest",
    chainId,
    args: [about, formattedKey, createValue(value)]
  });
};

// src/lib/prepareWriteAttestations.ts
import { prepareWriteContract as prepareWriteContract2 } from "@wagmi/core";
import { formatBytes32String as formatBytes32String3 } from "ethers/lib/utils.js";
var prepareWriteAttestations = async (attestations, chainId = void 0, contractAddress = ATTESTATION_STATION_ADDRESS) => {
  const formattedAttestations = attestations.map((attestation) => {
    let formattedKey;
    try {
      formattedKey = formatBytes32String3(attestation.key);
    } catch (e) {
      console.error(e);
      throw new Error(
        `key is longer than 32 bytes: ${attestation.key}.  Try using a shorter key or using 'encodeRawKey' to encode the key into 32 bytes first`
      );
    }
    const formattedValue = createValue(attestation.value);
    return {
      about: attestation.about,
      key: formattedKey,
      val: formattedValue
    };
  });
  return prepareWriteContract2({
    address: contractAddress,
    abi,
    functionName: "attest",
    chainId,
    args: [formattedAttestations]
  });
};

// src/lib/writeAttestation.ts
import { writeContract } from "@wagmi/core";
var writeAttestation = writeContract;
export {
  ATTESTATION_STATION_ADDRESS,
  abi,
  createKey,
  createValue,
  encodeRawKey,
  getEvents,
  parseAddress,
  parseAttestationBytes,
  parseBool,
  parseNumber,
  parseString,
  prepareWriteAttestation,
  prepareWriteAttestations,
  readAttestation,
  readAttestationAddress,
  readAttestationBool,
  readAttestationNumber,
  readAttestationString,
  readAttestations,
  stringifyAttestationBytes,
  writeAttestation
};
//# sourceMappingURL=index.js.map