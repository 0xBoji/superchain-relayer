#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/lib/logger.ts
var import_util, import_ora, import_picocolors, format, info, log, error, spinner;
var init_logger = __esm({
  "src/lib/logger.ts"() {
    "use strict";
    import_util = __toESM(require("util"), 1);
    import_ora = __toESM(require("ora"), 1);
    import_picocolors = __toESM(require("picocolors"), 1);
    format = (args) => {
      return import_util.default.format(...args).split("\n").join("\n");
    };
    info = (...args) => {
      console.info(import_picocolors.default.blue(format(args)));
    };
    log = (...args) => {
      console.log(import_picocolors.default.white(format(args)));
    };
    error = (...args) => {
      console.error(import_picocolors.default.red(format(args)));
    };
    spinner = () => {
      return (0, import_ora.default)({
        color: "gray",
        spinner: "dots8Bit"
      });
    };
  }
});

// src/types/DataTypeOption.ts
var import_zod, DEFAULT_DATA_TYPE, dataTypeOptionValidator;
var init_DataTypeOption = __esm({
  "src/types/DataTypeOption.ts"() {
    "use strict";
    import_zod = require("zod");
    DEFAULT_DATA_TYPE = "string";
    dataTypeOptionValidator = import_zod.z.union([
      import_zod.z.literal("string"),
      import_zod.z.literal("bytes"),
      import_zod.z.literal("number"),
      import_zod.z.literal("bool"),
      import_zod.z.literal("address")
    ]).optional().default("string").describe(`Zod validator for the DataType type
 string | bytes | number | bool | address`);
  }
});

// src/constants/attestationStationAddress.ts
var ATTESTATION_STATION_ADDRESS;
var init_attestationStationAddress = __esm({
  "src/constants/attestationStationAddress.ts"() {
    "use strict";
    ATTESTATION_STATION_ADDRESS = "0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77";
  }
});

// src/constants/defaultRpcUrl.ts
var DEFAULT_RPC_URL;
var init_defaultRpcUrl = __esm({
  "src/constants/defaultRpcUrl.ts"() {
    "use strict";
    DEFAULT_RPC_URL = "https://mainnet.optimism.io";
  }
});

// src/lib/abi.ts
var abi;
var init_abi = __esm({
  "src/lib/abi.ts"() {
    "use strict";
    abi = [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "address",
            name: "creator",
            type: "address"
          },
          {
            indexed: true,
            internalType: "address",
            name: "about",
            type: "address"
          },
          {
            indexed: true,
            internalType: "bytes32",
            name: "key",
            type: "bytes32"
          },
          {
            indexed: false,
            internalType: "bytes",
            name: "val",
            type: "bytes"
          }
        ],
        name: "AttestationCreated",
        type: "event"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "address",
                name: "about",
                type: "address"
              },
              {
                internalType: "bytes32",
                name: "key",
                type: "bytes32"
              },
              {
                internalType: "bytes",
                name: "val",
                type: "bytes"
              }
            ],
            internalType: "struct AttestationStation.AttestationData[]",
            name: "_attestations",
            type: "tuple[]"
          }
        ],
        name: "attest",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_about",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "_key",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "_val",
            type: "bytes"
          }
        ],
        name: "attest",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "attestations",
        outputs: [
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "version",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ];
  }
});

// src/lib/parseAttestationBytes.ts
var import_ethers, import_utils, parseString, parseBool, parseNumber, parseAddress, parseAttestationBytes;
var init_parseAttestationBytes = __esm({
  "src/lib/parseAttestationBytes.ts"() {
    "use strict";
    import_ethers = require("ethers");
    import_utils = require("ethers/lib/utils.js");
    parseString = (rawAttestation) => {
      rawAttestation = rawAttestation === "0x0" ? "0x" : rawAttestation;
      return rawAttestation ? (0, import_utils.toUtf8String)(rawAttestation) : "";
    };
    parseBool = (rawAttestation) => {
      rawAttestation = rawAttestation === "0x" ? "0x0" : rawAttestation;
      return rawAttestation ? import_ethers.BigNumber.from(rawAttestation).gt(0) : false;
    };
    parseNumber = (rawAttestation) => {
      rawAttestation = rawAttestation === "0x" ? "0x0" : rawAttestation;
      return rawAttestation ? import_ethers.BigNumber.from(rawAttestation) : import_ethers.BigNumber.from(0);
    };
    parseAddress = (rawAttestation) => {
      rawAttestation = rawAttestation === "0x" ? "0x0" : rawAttestation;
      return rawAttestation ? import_ethers.BigNumber.from(rawAttestation).toHexString() : "0x0000000000000000000000000000000000000000";
    };
    parseAttestationBytes = (attestationBytes, dataType) => {
      if (dataType === "bytes") {
        return attestationBytes;
      }
      if (dataType === "number") {
        return parseNumber(attestationBytes);
      }
      if (dataType === "address") {
        return parseAddress(attestationBytes);
      }
      if (dataType === "bool") {
        return parseBool(attestationBytes);
      }
      if (dataType === "string") {
        return parseString(attestationBytes);
      }
      console.warn(`unrecognized dataType ${dataType}`);
      return attestationBytes;
    };
  }
});

// src/lib/readAttestations.ts
var import_core, import_utils2, readAttestations;
var init_readAttestations = __esm({
  "src/lib/readAttestations.ts"() {
    "use strict";
    import_core = require("@wagmi/core");
    import_utils2 = require("ethers/lib/utils.js");
    init_attestationStationAddress();
    init_DataTypeOption();
    init_abi();
    init_parseAttestationBytes();
    readAttestations = async (...attestationReads) => {
      const calls = attestationReads.map((attestation) => {
        const {
          creator,
          about,
          key,
          contractAddress = ATTESTATION_STATION_ADDRESS
        } = attestation;
        if (key.length > 32) {
          throw new Error(
            "Key is longer than the max length of 32 for attestation keys"
          );
        }
        return {
          address: contractAddress,
          abi,
          functionName: "attestations",
          args: [creator, about, (0, import_utils2.formatBytes32String)(key)]
        };
      });
      const results = await (0, import_core.readContracts)({
        contracts: calls
      });
      return results.map((dataBytes, i) => {
        const dataType = attestationReads[i].dataType ?? DEFAULT_DATA_TYPE;
        return parseAttestationBytes(dataBytes, dataType);
      });
    };
  }
});

// src/lib/readAttestation.ts
var readAttestation;
var init_readAttestation = __esm({
  "src/lib/readAttestation.ts"() {
    "use strict";
    init_readAttestations();
    readAttestation = async (creator, about, key, dataType, contractAddress = "0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77") => {
      const [result] = await readAttestations({
        creator,
        about,
        key,
        contractAddress,
        dataType
      });
      return result;
    };
  }
});

// src/commands/read.ts
var read_exports = {};
__export(read_exports, {
  read: () => read,
  readOptionsValidators: () => readOptionsValidators
});
var import_core2, import_utils3, import_zod2, import_ethers2, zodAddress, readOptionsValidators, validators, read;
var init_read = __esm({
  "src/commands/read.ts"() {
    "use strict";
    import_core2 = require("@wagmi/core");
    import_utils3 = require("ethers/lib/utils.js");
    import_zod2 = require("zod");
    import_ethers2 = require("ethers");
    init_logger();
    init_DataTypeOption();
    init_attestationStationAddress();
    init_defaultRpcUrl();
    init_readAttestation();
    zodAddress = () => import_zod2.z.string().transform((addr) => addr).refine(import_utils3.isAddress, { message: "Invalid address" });
    readOptionsValidators = {
      creator: zodAddress().describe("Address of the creator of the attestation"),
      about: zodAddress().describe("Address of the subject of the attestation"),
      key: import_zod2.z.string().describe("Key of the attestation either as string or hex number"),
      dataType: dataTypeOptionValidator,
      rpcUrl: import_zod2.z.string().url().optional().default(DEFAULT_RPC_URL).describe("Rpc url to use"),
      contract: zodAddress().optional().default(ATTESTATION_STATION_ADDRESS).describe("Contract address to read from")
    };
    validators = import_zod2.z.object(readOptionsValidators);
    read = async (options) => {
      const parsedOptions = await validators.parseAsync(options).catch((e) => {
        error(e);
        process.exit(1);
      });
      const provider = new import_ethers2.providers.JsonRpcProvider({
        url: parsedOptions.rpcUrl,
        headers: {
          "User-Agent": "@eth-optimism/atst"
        }
      });
      (0, import_core2.createClient)({
        provider
      });
      try {
        const result = await readAttestation(
          parsedOptions.creator,
          parsedOptions.about,
          parsedOptions.key,
          parsedOptions.dataType,
          parsedOptions.contract
        );
        log(result?.toString());
        return result?.toString();
      } catch (e) {
        error("Unable to read attestation", e);
        process.exit(1);
      }
    };
  }
});

// src/lib/createValue.ts
var import_ethers3, import_utils4, createValue;
var init_createValue = __esm({
  "src/lib/createValue.ts"() {
    "use strict";
    import_ethers3 = require("ethers");
    import_utils4 = require("ethers/lib/utils.js");
    createValue = (bytes) => {
      bytes = bytes === "0x" ? "0x0" : bytes;
      if (import_ethers3.BigNumber.isBigNumber(bytes)) {
        return bytes.toHexString();
      }
      if (typeof bytes === "number") {
        return import_ethers3.BigNumber.from(bytes).toHexString();
      }
      if (typeof bytes === "boolean") {
        return bytes ? "0x1" : "0x0";
      }
      if ((0, import_utils4.isAddress)(bytes)) {
        return bytes;
      }
      if ((0, import_utils4.isHexString)(bytes)) {
        return bytes;
      }
      if (typeof bytes === "string") {
        return (0, import_utils4.hexlify)((0, import_utils4.toUtf8Bytes)(bytes));
      }
      throw new Error(`unrecognized bytes type ${bytes}`);
    };
  }
});

// src/lib/prepareWriteAttestation.ts
var import_core3, import_utils5, prepareWriteAttestation;
var init_prepareWriteAttestation = __esm({
  "src/lib/prepareWriteAttestation.ts"() {
    "use strict";
    import_core3 = require("@wagmi/core");
    import_utils5 = require("ethers/lib/utils.js");
    init_attestationStationAddress();
    init_abi();
    init_createValue();
    prepareWriteAttestation = async (about, key, value, chainId = void 0, contractAddress = ATTESTATION_STATION_ADDRESS) => {
      let formattedKey;
      try {
        formattedKey = (0, import_utils5.formatBytes32String)(key);
      } catch (e) {
        console.error(e);
        throw new Error(
          `key is longer than 32 bytes: ${key}.  Try using a shorter key or using 'encodeRawKey' to encode the key into 32 bytes first`
        );
      }
      return (0, import_core3.prepareWriteContract)({
        address: contractAddress,
        abi,
        functionName: "attest",
        chainId,
        args: [about, formattedKey, createValue(value)]
      });
    };
  }
});

// src/lib/writeAttestation.ts
var import_core4, writeAttestation;
var init_writeAttestation = __esm({
  "src/lib/writeAttestation.ts"() {
    "use strict";
    import_core4 = require("@wagmi/core");
    init_prepareWriteAttestation();
    init_abi();
    writeAttestation = import_core4.writeContract;
  }
});

// src/lib/castAsDataType.ts
var castAsDataType;
var init_castAsDataType = __esm({
  "src/lib/castAsDataType.ts"() {
    "use strict";
    castAsDataType = (value, dataType) => {
      if (dataType === "string") {
        return value;
      } else if (dataType === "number") {
        return Number(value);
      } else if (dataType === "bool") {
        return Boolean(value);
      } else if (dataType === "bytes") {
        return value;
      } else if (dataType === "address") {
        return value;
      } else {
        throw new Error(`Unrecognized data type ${dataType}`);
      }
    };
  }
});

// src/commands/write.ts
var write_exports = {};
__export(write_exports, {
  write: () => write,
  writeOptionsValidators: () => writeOptionsValidators
});
var import_core5, import_utils6, import_zod3, import_ethers4, import_mock, zodAddress2, zodWallet, zodAttestation, writeOptionsValidators, validators2, write;
var init_write = __esm({
  "src/commands/write.ts"() {
    "use strict";
    import_core5 = require("@wagmi/core");
    import_utils6 = require("ethers/lib/utils.js");
    import_zod3 = require("zod");
    import_ethers4 = require("ethers");
    import_mock = require("@wagmi/core/connectors/mock");
    init_logger();
    init_attestationStationAddress();
    init_defaultRpcUrl();
    init_prepareWriteAttestation();
    init_writeAttestation();
    init_castAsDataType();
    init_DataTypeOption();
    zodAddress2 = () => import_zod3.z.string().transform((addr) => addr).refine(import_utils6.isAddress, { message: "Invalid address" });
    zodWallet = () => import_zod3.z.string().refine((key) => new import_ethers4.Wallet(key));
    zodAttestation = () => import_zod3.z.union([import_zod3.z.string(), import_zod3.z.number(), import_zod3.z.boolean()]);
    writeOptionsValidators = {
      privateKey: zodWallet().describe("Address of the creator of the attestation"),
      about: zodAddress2().describe("Address of the subject of the attestation"),
      key: import_zod3.z.string().describe("Key of the attestation either as string or hex number"),
      value: zodAttestation().describe("Attestation value").default(""),
      dataType: dataTypeOptionValidator,
      rpcUrl: import_zod3.z.string().url().optional().default(DEFAULT_RPC_URL).describe("Rpc url to use"),
      contract: zodAddress2().optional().default(ATTESTATION_STATION_ADDRESS).describe("Contract address to read from")
    };
    validators2 = import_zod3.z.object(writeOptionsValidators);
    write = async (options) => {
      const parsedOptions = await validators2.parseAsync(options).catch((e) => {
        error(e);
        process.exit(1);
      });
      const provider = new import_ethers4.providers.JsonRpcProvider({
        url: parsedOptions.rpcUrl,
        headers: {
          "User-Agent": "@eth-optimism/atst"
        }
      });
      (0, import_core5.createClient)({
        provider
      });
      const network = await provider.getNetwork();
      if (!network) {
        error("Unable to detect chainId");
        process.exit(1);
      }
      await (0, import_core5.connect)({
        connector: new import_mock.MockConnector({
          options: {
            chainId: network.chainId,
            signer: new import_ethers4.Wallet(parsedOptions.privateKey, provider)
          }
        })
      });
      try {
        const preparedTx = await prepareWriteAttestation(
          parsedOptions.about,
          parsedOptions.key,
          castAsDataType(parsedOptions.value, parsedOptions.dataType),
          network.chainId
        );
        const result = await writeAttestation(preparedTx);
        await result.wait();
        log(`txHash: ${result.hash}`);
        return result.hash;
      } catch (e) {
        error("Unable to read attestation", e);
        process.exit(1);
      }
    };
  }
});

// src/cli.ts
var import_cac = require("cac");
init_read();
init_logger();

// package.json
var package_default = {
  name: "@eth-optimism/atst",
  version: "0.1.0",
  type: "module",
  main: "dist/index.js",
  types: "src/index.ts",
  module: "dist/index.cjs",
  license: "MIT",
  exports: {
    ".": {
      types: "./src/index.ts",
      default: "./dist/index.js",
      import: "./dist/index.js",
      require: "./dist/index.cjs"
    },
    "./react": {
      types: "./src/react.ts",
      default: "./dist/react.js",
      import: "./dist/react.js",
      require: "./dist/react.cjs"
    }
  },
  bin: {
    atst: "./dist/cli.js"
  },
  scripts: {
    dev: "tsx src/cli.ts",
    clean: "rm -rf ./node_modules && rm -rf ./dist && rm -rf ./coverage",
    build: "yarn tsup",
    generate: "wagmi generate",
    lint: "yarn lint:fix && yarn lint:check",
    "lint:check": "eslint . --max-warnings=0",
    "lint:fix": "yarn lint:check --fix",
    test: "vitest",
    typecheck: "yarn tsc --noEmit"
  },
  dependencies: {
    cac: "^6.7.14",
    picocolors: "^1.0.0",
    ora: "^6.1.2",
    zod: "^3.11.6"
  },
  peerDependencies: {
    "@wagmi/core": ">0.9.0",
    wagmi: ">0.11.0",
    ethers: "^5.0.0"
  },
  devDependencies: {
    "@testing-library/react-hooks": "^8.0.1",
    ethers: "^5.7.0",
    jsdom: "^21.1.0",
    "react-dom": "^18.2.0",
    react: "^18.2.0",
    execa: "^1.0.0",
    vitest: "^0.28.3",
    tsup: "^6.5.0",
    tsx: "^3.12.2",
    typescript: "^4.9.3",
    "@wagmi/core": "^0.9.2",
    "@wagmi/cli": "~0.1.5",
    wagmi: "~0.11.0"
  }
};

// src/cli.ts
init_write();
var cli = (0, import_cac.cac)("atst");
cli.command("read", "read an attestation").option("--creator <string>", readOptionsValidators.creator.description).option("--about <string>", readOptionsValidators.about.description).option("--key <string>", readOptionsValidators.key.description).option("--data-type <string>", readOptionsValidators.dataType.description, {
  default: readOptionsValidators.dataType.parse(void 0)
}).option("--rpc-url <url>", readOptionsValidators.rpcUrl.description, {
  default: readOptionsValidators.rpcUrl.parse(void 0)
}).option("--contract <address>", readOptionsValidators.contract.description, {
  default: readOptionsValidators.contract.parse(void 0)
}).example(
  () => `atst read --key "optimist.base-uri" --about 0x2335022c740d17c2837f9C884Bfe4fFdbf0A95D5 --creator 0x60c5C9c98bcBd0b0F2fD89B24c16e533BaA8CdA3`
).action(async (options) => {
  const { read: read2 } = await Promise.resolve().then(() => (init_read(), read_exports));
  const { rawArgs } = cli;
  const about = rawArgs[rawArgs.indexOf("--about") + 1];
  const creator = rawArgs[rawArgs.indexOf("--creator") + 1];
  const contract = rawArgs.includes("--contract") ? rawArgs[rawArgs.indexOf("--contract") + 1] : options.contract;
  await read2({ ...options, about, creator, contract });
});
cli.command("write", "write an attestation").option(
  "--private-key <string>",
  writeOptionsValidators.privateKey.description
).option("--data-type <string>", readOptionsValidators.dataType.description, {
  default: writeOptionsValidators.dataType.parse(void 0)
}).option("--about <string>", writeOptionsValidators.about.description).option("--key <string>", writeOptionsValidators.key.description).option("--value <string>", writeOptionsValidators.value.description).option("--rpc-url <url>", writeOptionsValidators.rpcUrl.description, {
  default: writeOptionsValidators.rpcUrl.parse(void 0)
}).option(
  "--contract <address>",
  writeOptionsValidators.contract.description,
  {
    default: writeOptionsValidators.contract.parse(void 0)
  }
).example(
  () => `atst write --key "optimist.base-uri" --about 0x2335022c740d17c2837f9C884Bfe4fFdbf0A95D5 --value "my attestation" --private-key 0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80 --rpc-url http://localhost:8545`
).action(async (options) => {
  const spinner2 = spinner();
  spinner2.start("Writing attestation...");
  const { write: write2 } = await Promise.resolve().then(() => (init_write(), write_exports));
  const { rawArgs } = cli;
  const privateKey = rawArgs[rawArgs.indexOf("--private-key") + 1];
  const about = rawArgs[rawArgs.indexOf("--about") + 1];
  const contract = rawArgs.includes("--contract") ? rawArgs[rawArgs.indexOf("--contract") + 1] : options.contract;
  await write2({ ...options, about, privateKey, contract }).then((res) => {
    spinner2.succeed("Attestation written!");
    info(`Attestation hash: ${res}`);
  }).catch((e) => {
    error(e);
    spinner2.fail("Attestation failed!");
  });
});
cli.version(package_default.version);
void (async () => {
  try {
    cli.parse(process.argv, { run: false });
    if (!cli.matchedCommand && cli.args.length === 0) {
      cli.outputHelp();
    }
    await cli.runMatchedCommand();
  } catch (error2) {
    error(`
${error2.message}`);
    process.exit(1);
  }
})();
//# sourceMappingURL=cli.cjs.map