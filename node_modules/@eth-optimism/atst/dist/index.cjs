"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ATTESTATION_STATION_ADDRESS: () => ATTESTATION_STATION_ADDRESS,
  abi: () => abi,
  createKey: () => createKey,
  createValue: () => createValue,
  encodeRawKey: () => encodeRawKey,
  getEvents: () => getEvents,
  parseAddress: () => parseAddress,
  parseAttestationBytes: () => parseAttestationBytes,
  parseBool: () => parseBool,
  parseNumber: () => parseNumber,
  parseString: () => parseString,
  prepareWriteAttestation: () => prepareWriteAttestation,
  prepareWriteAttestations: () => prepareWriteAttestations,
  readAttestation: () => readAttestation,
  readAttestationAddress: () => readAttestationAddress,
  readAttestationBool: () => readAttestationBool,
  readAttestationNumber: () => readAttestationNumber,
  readAttestationString: () => readAttestationString,
  readAttestations: () => readAttestations,
  stringifyAttestationBytes: () => stringifyAttestationBytes,
  writeAttestation: () => writeAttestation
});
module.exports = __toCommonJS(src_exports);

// src/constants/attestationStationAddress.ts
var ATTESTATION_STATION_ADDRESS = "0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77";

// src/lib/createKey.ts
var import_ethers = require("ethers");
var createKey = (rawKey) => {
  if (rawKey.length < 32) {
    return import_ethers.ethers.utils.formatBytes32String(rawKey);
  }
  const hash = import_ethers.ethers.utils.keccak256(import_ethers.ethers.utils.toUtf8Bytes(rawKey));
  return hash.slice(0, 64) + "ff";
};
var encodeRawKey = (rawKey) => {
  console.warn("encodeRawKey is deprecated, use createKey instead");
  return createKey(rawKey);
};

// src/lib/createValue.ts
var import_ethers2 = require("ethers");
var import_utils = require("ethers/lib/utils.js");
var createValue = (bytes) => {
  bytes = bytes === "0x" ? "0x0" : bytes;
  if (import_ethers2.BigNumber.isBigNumber(bytes)) {
    return bytes.toHexString();
  }
  if (typeof bytes === "number") {
    return import_ethers2.BigNumber.from(bytes).toHexString();
  }
  if (typeof bytes === "boolean") {
    return bytes ? "0x1" : "0x0";
  }
  if ((0, import_utils.isAddress)(bytes)) {
    return bytes;
  }
  if ((0, import_utils.isHexString)(bytes)) {
    return bytes;
  }
  if (typeof bytes === "string") {
    return (0, import_utils.hexlify)((0, import_utils.toUtf8Bytes)(bytes));
  }
  throw new Error(`unrecognized bytes type ${bytes}`);
};
var stringifyAttestationBytes = (bytes) => {
  console.warn(
    "stringifyAttestationBytes is deprecated, use createValue instead"
  );
  return createValue(bytes);
};

// src/lib/readAttestations.ts
var import_core = require("@wagmi/core");
var import_utils3 = require("ethers/lib/utils.js");

// src/types/DataTypeOption.ts
var import_zod = require("zod");
var DEFAULT_DATA_TYPE = "string";
var dataTypeOptionValidator = import_zod.z.union([
  import_zod.z.literal("string"),
  import_zod.z.literal("bytes"),
  import_zod.z.literal("number"),
  import_zod.z.literal("bool"),
  import_zod.z.literal("address")
]).optional().default("string").describe(`Zod validator for the DataType type
 string | bytes | number | bool | address`);

// src/lib/abi.ts
var abi = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "about",
        type: "address"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "key",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "val",
        type: "bytes"
      }
    ],
    name: "AttestationCreated",
    type: "event"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "about",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "key",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "val",
            type: "bytes"
          }
        ],
        internalType: "struct AttestationStation.AttestationData[]",
        name: "_attestations",
        type: "tuple[]"
      }
    ],
    name: "attest",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_about",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "_key",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "_val",
        type: "bytes"
      }
    ],
    name: "attest",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "attestations",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// src/lib/parseAttestationBytes.ts
var import_ethers3 = require("ethers");
var import_utils2 = require("ethers/lib/utils.js");
var parseString = (rawAttestation) => {
  rawAttestation = rawAttestation === "0x0" ? "0x" : rawAttestation;
  return rawAttestation ? (0, import_utils2.toUtf8String)(rawAttestation) : "";
};
var parseBool = (rawAttestation) => {
  rawAttestation = rawAttestation === "0x" ? "0x0" : rawAttestation;
  return rawAttestation ? import_ethers3.BigNumber.from(rawAttestation).gt(0) : false;
};
var parseNumber = (rawAttestation) => {
  rawAttestation = rawAttestation === "0x" ? "0x0" : rawAttestation;
  return rawAttestation ? import_ethers3.BigNumber.from(rawAttestation) : import_ethers3.BigNumber.from(0);
};
var parseAddress = (rawAttestation) => {
  rawAttestation = rawAttestation === "0x" ? "0x0" : rawAttestation;
  return rawAttestation ? import_ethers3.BigNumber.from(rawAttestation).toHexString() : "0x0000000000000000000000000000000000000000";
};
var parseAttestationBytes = (attestationBytes, dataType) => {
  if (dataType === "bytes") {
    return attestationBytes;
  }
  if (dataType === "number") {
    return parseNumber(attestationBytes);
  }
  if (dataType === "address") {
    return parseAddress(attestationBytes);
  }
  if (dataType === "bool") {
    return parseBool(attestationBytes);
  }
  if (dataType === "string") {
    return parseString(attestationBytes);
  }
  console.warn(`unrecognized dataType ${dataType}`);
  return attestationBytes;
};

// src/lib/readAttestations.ts
var readAttestations = async (...attestationReads) => {
  const calls = attestationReads.map((attestation) => {
    const {
      creator,
      about,
      key,
      contractAddress = ATTESTATION_STATION_ADDRESS
    } = attestation;
    if (key.length > 32) {
      throw new Error(
        "Key is longer than the max length of 32 for attestation keys"
      );
    }
    return {
      address: contractAddress,
      abi,
      functionName: "attestations",
      args: [creator, about, (0, import_utils3.formatBytes32String)(key)]
    };
  });
  const results = await (0, import_core.readContracts)({
    contracts: calls
  });
  return results.map((dataBytes, i) => {
    const dataType = attestationReads[i].dataType ?? DEFAULT_DATA_TYPE;
    return parseAttestationBytes(dataBytes, dataType);
  });
};

// src/lib/readAttestation.ts
var readAttestation = async (creator, about, key, dataType, contractAddress = "0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77") => {
  const [result] = await readAttestations({
    creator,
    about,
    key,
    contractAddress,
    dataType
  });
  return result;
};
var readAttestationString = (creator, about, key, contractAddress = "0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77") => {
  return readAttestation(
    creator,
    about,
    key,
    "string",
    contractAddress
  );
};
var readAttestationBool = (creator, about, key, contractAddress = "0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77") => {
  return readAttestation(
    creator,
    about,
    key,
    "bool",
    contractAddress
  );
};
var readAttestationNumber = (creator, about, key, contractAddress = "0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77") => {
  return readAttestation(
    creator,
    about,
    key,
    "number",
    contractAddress
  );
};
var readAttestationAddress = (creator, about, key, contractAddress = "0xEE36eaaD94d1Cc1d0eccaDb55C38bFfB6Be06C77") => {
  return readAttestation(
    creator,
    about,
    key,
    "address",
    contractAddress
  );
};

// src/lib/getEvents.ts
var import_ethers4 = require("ethers");
var getEvents = async ({
  creator = null,
  about = null,
  key = null,
  value = null,
  provider,
  fromBlockOrBlockhash,
  toBlock
}) => {
  const contract = new import_ethers4.ethers.Contract(
    ATTESTATION_STATION_ADDRESS,
    abi,
    provider
  );
  return contract.queryFilter(
    contract.filters.AttestationCreated(
      creator,
      about,
      key && encodeRawKey(key),
      value
    ),
    fromBlockOrBlockhash,
    toBlock
  );
};

// src/lib/prepareWriteAttestation.ts
var import_core2 = require("@wagmi/core");
var import_utils4 = require("ethers/lib/utils.js");
var prepareWriteAttestation = async (about, key, value, chainId = void 0, contractAddress = ATTESTATION_STATION_ADDRESS) => {
  let formattedKey;
  try {
    formattedKey = (0, import_utils4.formatBytes32String)(key);
  } catch (e) {
    console.error(e);
    throw new Error(
      `key is longer than 32 bytes: ${key}.  Try using a shorter key or using 'encodeRawKey' to encode the key into 32 bytes first`
    );
  }
  return (0, import_core2.prepareWriteContract)({
    address: contractAddress,
    abi,
    functionName: "attest",
    chainId,
    args: [about, formattedKey, createValue(value)]
  });
};

// src/lib/prepareWriteAttestations.ts
var import_core3 = require("@wagmi/core");
var import_utils5 = require("ethers/lib/utils.js");
var prepareWriteAttestations = async (attestations, chainId = void 0, contractAddress = ATTESTATION_STATION_ADDRESS) => {
  const formattedAttestations = attestations.map((attestation) => {
    let formattedKey;
    try {
      formattedKey = (0, import_utils5.formatBytes32String)(attestation.key);
    } catch (e) {
      console.error(e);
      throw new Error(
        `key is longer than 32 bytes: ${attestation.key}.  Try using a shorter key or using 'encodeRawKey' to encode the key into 32 bytes first`
      );
    }
    const formattedValue = createValue(attestation.value);
    return {
      about: attestation.about,
      key: formattedKey,
      val: formattedValue
    };
  });
  return (0, import_core3.prepareWriteContract)({
    address: contractAddress,
    abi,
    functionName: "attest",
    chainId,
    args: [formattedAttestations]
  });
};

// src/lib/writeAttestation.ts
var import_core4 = require("@wagmi/core");
var writeAttestation = import_core4.writeContract;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ATTESTATION_STATION_ADDRESS,
  abi,
  createKey,
  createValue,
  encodeRawKey,
  getEvents,
  parseAddress,
  parseAttestationBytes,
  parseBool,
  parseNumber,
  parseString,
  prepareWriteAttestation,
  prepareWriteAttestations,
  readAttestation,
  readAttestationAddress,
  readAttestationBool,
  readAttestationNumber,
  readAttestationString,
  readAttestations,
  stringifyAttestationBytes,
  writeAttestation
});
//# sourceMappingURL=index.cjs.map