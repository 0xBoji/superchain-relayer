import {
  require_buffer
} from "./chunk-UEV5ASBE.js";
import {
  __toESM
} from "./chunk-JZQ37OGZ.js";

// node_modules/proxy-compare/dist/index.modern.js
var e = Symbol();
var t = Symbol();
var s = Object.getPrototypeOf;
var c = /* @__PURE__ */ new WeakMap();
var l = (e2) => e2 && (c.has(e2) ? c.get(e2) : s(e2) === Object.prototype || s(e2) === Array.prototype);
var g = (e2) => l(e2) && e2[t] || null;
var h = (e2, t2 = true) => {
  c.set(e2, t2);
};

// node_modules/valtio/esm/vanilla.mjs
var isObject = (x) => typeof x === "object" && x !== null;
var proxyStateMap = /* @__PURE__ */ new WeakMap();
var refSet = /* @__PURE__ */ new WeakSet();
var buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache = snapCache.get(target);
  if ((cache == null ? void 0 : cache[0]) === version) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  h(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet.has(value)) {
      h(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap.has(value)) {
      snap[key] = snapshot(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {
  if (!isObject(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if ((import.meta.env && import.meta.env.MODE) !== "production" && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a = entry[1]) == null ? void 0 : _a.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if ((import.meta.env && import.meta.env.MODE) !== "production" && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove], prop) => {
          if (remove) {
            remove();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && objectIs(prevValue, value)) {
        return true;
      }
      removePropListener(prop);
      if (isObject(value)) {
        value = g(value) || value;
      }
      let nextValue = value;
      if ((_a = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a.set)
        ;
      else if (value instanceof Promise) {
        value.then((v2) => {
          value.status = "fulfilled";
          value.value = v2;
          notifyUpdate(["resolve", [prop], v2]);
        }).catch((e2) => {
          value.status = "rejected";
          value.reason = e2;
          notifyUpdate(["reject", [prop], e2]);
        });
      } else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxy(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [
    baseObject,
    ensureVersion,
    createSnapshot,
    addListener
  ];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(
      initialObject,
      key
    );
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction2,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((import.meta.env && import.meta.env.MODE) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject, handlePromise) {
  const proxyState = proxyStateMap.get(proxyObject);
  if ((import.meta.env && import.meta.env.MODE) !== "production" && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}

// node_modules/@web3modal/core/dist/index.js
var import_buffer = __toESM(require_buffer());
var n = proxy({ selectedChain: void 0, chains: void 0, standaloneChains: void 0, standaloneUri: void 0, address: void 0, profileName: void 0, profileAvatar: void 0, profileLoading: false, balanceLoading: false, balance: void 0, isConnected: false, isStandalone: false, isCustomDesktop: false, isCustomMobile: false, isDataLoaded: false, isUiLoaded: false, walletConnectVersion: 1 });
var a = { state: n, subscribe(e2) {
  return subscribe(n, () => e2(n));
}, setChains(e2) {
  n.chains = e2;
}, setStandaloneChains(e2) {
  n.standaloneChains = e2;
}, setStandaloneUri(e2) {
  n.standaloneUri = e2;
}, getSelectedChain() {
  const e2 = L.client().getNetwork().chain;
  return e2 && (n.selectedChain = e2), n.selectedChain;
}, setSelectedChain(e2) {
  n.selectedChain = e2;
}, setIsStandalone(e2) {
  n.isStandalone = e2;
}, setIsCustomDesktop(e2) {
  n.isCustomDesktop = e2;
}, setIsCustomMobile(e2) {
  n.isCustomMobile = e2;
}, getAccount() {
  const e2 = L.client().getAccount();
  n.address = e2.address, n.isConnected = e2.isConnected;
}, setAddress(e2) {
  n.address = e2;
}, setIsConnected(e2) {
  n.isConnected = e2;
}, setProfileName(e2) {
  n.profileName = e2;
}, setProfileAvatar(e2) {
  n.profileAvatar = e2;
}, setProfileLoading(e2) {
  n.profileLoading = e2;
}, setBalanceLoading(e2) {
  n.balanceLoading = e2;
}, setBalance(e2) {
  n.balance = e2;
}, setIsDataLoaded(e2) {
  n.isDataLoaded = e2;
}, setIsUiLoaded(e2) {
  n.isUiLoaded = e2;
}, setWalletConnectVersion(e2) {
  n.walletConnectVersion = e2;
}, resetEnsProfile() {
  n.profileName = void 0, n.profileAvatar = void 0;
}, resetBalance() {
  n.balance = void 0;
}, resetAccount() {
  n.address = void 0, n.isConnected = false, a.resetEnsProfile(), a.resetBalance();
} };
var h2 = proxy({ initialized: false, ethereumClient: void 0 });
var L = { setEthereumClient(e2) {
  !h2.initialized && e2 && (h2.ethereumClient = e2, a.setChains(e2.chains), h2.initialized = true);
}, client() {
  if (h2.ethereumClient)
    return h2.ethereumClient;
  throw new Error("ClientCtrl has no client set");
} };
var d = { WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE", isMobile() {
  return typeof window < "u" ? Boolean(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : false;
}, isAndroid() {
  return d.isMobile() && navigator.userAgent.toLowerCase().includes("android");
}, isEmptyObject(e2) {
  return Object.getPrototypeOf(e2) === Object.prototype && Object.getOwnPropertyNames(e2).length === 0 && Object.getOwnPropertySymbols(e2).length === 0;
}, isHttpUrl(e2) {
  return e2.startsWith("http://") || e2.startsWith("https://");
}, formatNativeUrl(e2, t2, s2) {
  if (d.isHttpUrl(e2))
    return this.formatUniversalUrl(e2, t2, s2);
  let o = e2;
  o.includes("://") || (o = e2.replaceAll("/", "").replaceAll(":", ""), o = `${o}://`), this.setWalletConnectDeepLink(o, s2);
  const l2 = encodeURIComponent(t2);
  return `${o}wc?uri=${l2}`;
}, formatUniversalUrl(e2, t2, s2) {
  if (!d.isHttpUrl(e2))
    return this.formatNativeUrl(e2, t2, s2);
  let o = e2;
  e2.endsWith("/") && (o = e2.slice(0, -1)), this.setWalletConnectDeepLink(o, s2);
  const l2 = encodeURIComponent(t2);
  return `${o}/wc?uri=${l2}`;
}, async wait(e2) {
  return new Promise((t2) => {
    setTimeout(t2, e2);
  });
}, openHref(e2, t2 = "_self") {
  window.open(e2, t2, "noreferrer noopener");
}, setWalletConnectDeepLink(e2, t2) {
  localStorage.setItem(d.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: e2, name: t2 }));
}, setWalletConnectAndroidDeepLink(e2) {
  const [t2] = e2.split("?");
  localStorage.setItem(d.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: t2, name: "Android" }));
}, removeWalletConnectDeepLink() {
  localStorage.removeItem(d.WALLETCONNECT_DEEPLINK_CHOICE);
}, isNull(e2) {
  return e2 === null;
} };
function S() {
  return typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)").matches;
}
var f = proxy({ projectId: "", themeMode: S() ? "dark" : "light", themeColor: "default", themeBackground: d.isMobile() ? "themeColor" : "gradient", themeZIndex: 89, mobileWallets: void 0, desktopWallets: void 0, walletImages: void 0, chainImages: void 0, tokenImages: void 0, standaloneChains: void 0, enableStandaloneMode: false, enableNetworkView: false, enableAccountView: true, defaultChain: void 0, explorerAllowList: void 0, explorerDenyList: void 0, termsOfServiceUrl: void 0, privacyPolicyUrl: void 0 });
var W = { state: f, subscribe(e2) {
  return subscribe(f, () => e2(f));
}, setConfig(e2) {
  var t2, s2, o, l2;
  if (a.setStandaloneChains(e2.standaloneChains), a.setIsStandalone(Boolean((t2 = e2.standaloneChains) == null ? void 0 : t2.length) || Boolean(e2.enableStandaloneMode)), a.setIsCustomMobile(Boolean((s2 = e2.mobileWallets) == null ? void 0 : s2.length)), a.setIsCustomDesktop(Boolean((o = e2.desktopWallets) == null ? void 0 : o.length)), a.setWalletConnectVersion((l2 = e2.walletConnectVersion) != null ? l2 : 1), e2.defaultChain)
    a.setSelectedChain(e2.defaultChain);
  else if (!a.state.isStandalone) {
    const u = L.client().getDefaultChain();
    a.setSelectedChain(u);
  }
  Object.assign(f, e2);
}, setThemeConfig(e2) {
  Object.assign(f, e2);
} };
var I = "https://explorer-api.walletconnect.com";
function y(e2) {
  const t2 = Object.fromEntries(Object.entries(e2).filter(([s2, o]) => typeof o < "u" && o !== null && o !== "").map(([s2, o]) => [s2, o.toString()]));
  return new URLSearchParams(t2).toString();
}
var v = { async fetchWallets(e2, t2) {
  const s2 = y(t2), o = `${I}/v3/wallets?projectId=${e2}&${s2}`;
  return (await fetch(o)).json();
}, formatImageUrl(e2, t2) {
  return `${I}/v3/logo/lg/${t2}?projectId=${e2}`;
} };
var r = proxy({ wallets: { listings: [], total: 0, page: 1 }, search: { listings: [], total: 0, page: 1 }, previewWallets: [], recomendedWallets: [] });
function b() {
  const { projectId: e2 } = W.state;
  if (!e2)
    throw new Error("projectId is required to work with explorer api");
  return e2;
}
var A = { state: r, async getPreviewWallets(e2) {
  const { listings: t2 } = await v.fetchWallets(b(), e2);
  return r.previewWallets = Object.values(t2), r.previewWallets;
}, async getRecomendedWallets() {
  const { listings: e2 } = await v.fetchWallets(b(), { page: 1, entries: 6 });
  r.recomendedWallets = Object.values(e2);
}, async getPaginatedWallets(e2) {
  const { page: t2, search: s2 } = e2, { listings: o, total: l2 } = await v.fetchWallets(b(), e2), u = Object.values(o), w = s2 ? "search" : "wallets";
  return r[w] = { listings: [...r[w].listings, ...u], total: l2, page: t2 ?? 1 }, { listings: u, total: l2 };
}, getImageUrl(e2) {
  return v.formatImageUrl(b(), e2);
}, resetSearch() {
  r.search = { listings: [], total: 0, page: 1 };
} };
var i = proxy({ history: ["ConnectWallet"], view: "ConnectWallet", data: void 0 });
var g2 = { state: i, subscribe(e2) {
  return subscribe(i, () => e2(i));
}, push(e2, t2) {
  e2 !== i.view && (i.view = e2, t2 && (i.data = t2), i.history.push(e2));
}, replace(e2) {
  i.view = e2, i.history = [e2];
}, goBack() {
  if (i.history.length > 1) {
    i.history.pop();
    const [e2] = i.history.slice(-1);
    i.view = e2;
  }
} };
var C = proxy({ open: false });
var k = { state: C, subscribe(e2) {
  return subscribe(C, () => e2(C));
}, async open(e2) {
  return new Promise((t2) => {
    const { isConnected: s2, isStandalone: o, isUiLoaded: l2, isDataLoaded: u } = a.state, { enableNetworkView: w } = W.state;
    if (o ? (a.setStandaloneUri(e2 == null ? void 0 : e2.uri), a.setStandaloneChains(e2 == null ? void 0 : e2.standaloneChains), g2.replace("ConnectWallet")) : e2 != null && e2.route ? g2.replace(e2.route) : s2 ? g2.replace("Account") : w ? g2.replace("SelectNetwork") : g2.replace("ConnectWallet"), l2 && u)
      C.open = true, t2();
    else {
      const E = setInterval(() => {
        a.state.isUiLoaded && a.state.isDataLoaded && (clearInterval(E), C.open = true, t2());
      }, 200);
    }
  });
}, close() {
  C.open = false;
} };
var c2 = proxy({ open: false, message: "", variant: "success" });
var P = { state: c2, subscribe(e2) {
  return subscribe(c2, () => e2(c2));
}, openToast(e2, t2) {
  c2.open = true, c2.message = e2, c2.variant = t2;
}, closeToast() {
  c2.open = false;
} };
typeof window < "u" && (window.Buffer || (window.Buffer = import_buffer.Buffer), window.global || (window.global = window), window.process || (window.process = { env: {} }));

export {
  a,
  L,
  d,
  W,
  A,
  g2 as g,
  k,
  P
};
//# sourceMappingURL=chunk-664I6QL7.js.map
